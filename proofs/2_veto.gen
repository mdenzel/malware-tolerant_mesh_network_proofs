(*
#if FALSE

  @title:    Malware-Tolerant Network
  @authors:  
  @date:     2018-02-26

  Warning: this is a raw file to generate ProVerif proofs.
  It includes C-macros and is not intended to be run directly.
  Please use the appended shellscript to generate the code.

#else
  GENERATED FILE

  @title:    Malware-Tolerant Network
  @authors:  
  @date:     __DATE__

#endif
*)

(* ###################### CONFIG SECTION ###################### *)
(*set reconstructTrace = true. (* REMARK: traces sometimes cannot be created;
                                         rather use proof output *)
(*set verboseRules = true. (* print every single rule *)
(*set explainDerivation = false.*)
(* ############################################################ *)

(* defines *)
type skey.
type pkey.
type key. (* symmetric key *)
type sig.

(* constants *)
const A1: bitstring.
const A2: bitstring.
const B1: bitstring.
const B2: bitstring.

(* #################### XXX: trust model #################### *)
    (* channels *)
    (* group g *)
    (* remark: g/g2 is a group and thus some devices are honest *)
    free ch_g:        channel .         (* public channel *)

    (* bridge group A *)
    free ch_A:       channel .          (* public channel *)
#if (A_COMPR)
    free kA:         skey    .
#else
    free kA:         skey    [private].
#endif

    (* bridge group B *)
    free ch_B:       channel .          (* public channel *)
#if (B_COMPR)
    free kB:         skey    .
#else
    free kB:         skey    [private].
#endif


(* ############################################################ *)


(* test variables to check if end of protocol etc. is reached *)
free success: bitstring [private].
free group2_leave: bitstring [private].
free ch_pub: channel. (* public channel *)

(* Symmetric encryption *)
fun senc(key, bitstring): bitstring.
reduc forall kx:key, m:bitstring; sdec(kx, senc(kx, m)) = m.

(* Asymmetric encryption *)
fun pk(skey): pkey.
fun aenc(pkey, bitstring): bitstring.
reduc forall kx:skey, m:bitstring; adec(kx, aenc(pk(kx), m)) = m.

(* typecast *)
fun pk2b(pkey): bitstring.
reduc forall k:pkey; b2pk(pk2b(k)) = k.

(* hash *)
fun mac(key, bitstring): bitstring.

(* signatures *)
fun sign(skey, bitstring): sig.
reduc forall kx:skey, m:bitstring; verify(pk(kx),m,sign(kx,m)) = m.



(* events to define control flows *)
event e_veto(pkey).
event e_Bridge_veto(bitstring, pkey). (* bridge device veto *)
event e_gd_veto(pkey, pkey). (* group device veto *)

(* #################### XXX: QUERIES #################### *)
(* protocol runs through *)
(* "not attacker(success)" should be false/cannot be proved! *)
query attacker(success).

(* check if attacker can get both bridge keys *)
query attacker(kA).
query attacker(kB).

(* can the attacker make another device leave another group? (group2_leave) *)
query attacker(group2_leave).

(* did veto work correctly? i.e. if there is a veto, gd1 and gd2
   voted a veto and the bridges were not skipped (= any bridge
   participated)
*)
query pk_d: pkey, k1: pkey, k2: pkey;
      event (e_veto(pk_d)) ==> (
                                 (
                                   event (e_Bridge_veto(A1, pk_d)) || event (e_Bridge_veto(A2, pk_d)) || 
                                   event (e_Bridge_veto(B1, pk_d)) || event (e_Bridge_veto(B2, pk_d))
                                 ) &&
                                 (event (e_gd_veto(k1, pk_d))    && event (e_gd_veto(k2, pk_d))) &&
                                 k1 <> k2
                               ).

(* ###################################################### *)


(* device d: only indirectly participating in the protocol *)

(* group g: the group d should leave *)
let g(
    (* input  *) ch_g: channel,
    (* output *)
    group: bitstring, pkA: pkey, pkB: pkey, time3: bitstring
    ) =
    in(ch_g, (pk_d: pkey, =time3, =group, veto_A: sig));
    let m = (pk_d, time3, group) in
    in(ch_g, (=m, veto_B: sig));
    (* check veto *)
    let (=m) = verify(pkA, m, veto_A) in
    let (=m) = verify(pkB, m, veto_B) in
    (* accept key *)
    event e_veto(pk_d);
    out(ch_pub, success).
    (* new group key agreement... *)

(* group g2: check if other groups can be forced to kick out devices *)
let g2(
    (* input  *) ch_pub: channel,
    (* output *)
    group2: bitstring, pkA: pkey, pkB: pkey, time3: bitstring
    ) =
    in(ch_pub, (m: bitstring, veto_A: sig, veto_B: sig));
    (* check veto *)
    let (=m) = verify(pkA, m, veto_A) in
    let (=m) = verify(pkB, m, veto_B) in
    (* check timestamp and group *)
    let (pk_d: pkey, =time3, =group2) = m in
    (* accept key *)
    out(ch_pub, group2_leave).

(* group device gd: votes to kick out d *)
let gd(
    (* input  *)
    (* output *) ch_A: channel, ch_B: channel,
    group: bitstring, k: skey, ticket_A: sig, ticket_B: sig,
    pk_d: pkey, time: bitstring
    ) =
    (* create veto *)
    let v = sign(k, (pk_d, group, time)) in
    (* originally we would sign the ticket of d here
       (incl. pkey/group/time) *)
    event e_gd_veto(pk(k), pk_d);
    out(ch_A, (pk_d, group, v, pk(k), ticket_A, ticket_B));
    out(ch_B, (pk_d, group, v, pk(k), ticket_A, ticket_B)).


(* bridge group A/B: each provides half of the veto *)
let Bridge(BrDev: bitstring, (* bridge device BrDev (e.g. A1, A2, B1, ...) *)
    (* input  *) ch_in: channel,
    (* output *) ch_g: channel,
    Ak: skey, pkA: pkey, pkB: pkey, time1: bitstring, time2: bitstring, time3: bitstring
    ) =
    (* handle request 1 *)
       in(ch_in, (pk_d: pkey, group: bitstring, v1: sig,
                 k1: pkey, ticket_A1: sig, ticket_B1: sig));
       (* check tickets *)
       let (=pk2b(k1)) = verify(pkA, pk2b(k1), ticket_A1) in
       let (=pk2b(k1)) = verify(pkB, pk2b(k1), ticket_B1) in
       (* check group veto 1 *)
       let (=pk_d, =group, =time1) = verify(k1, (pk_d, group, time1), v1) in
    (* handle request 2 *)
       in(ch_in, (=pk_d, =group, v2: sig, k2: pkey,
                 ticket_A2: sig, ticket_B2: sig));
       (* check tickets *)
       let (=pk2b(k2)) = verify(pkA, pk2b(k2), ticket_A2) in
       let (=pk2b(k2)) = verify(pkB, pk2b(k2), ticket_B2) in
       (* check group veto 2 *)
       let (=pk_d, =group, =time2) = verify(k2, (pk_d, group, time2), v2) in
       if k1 <> k2 && k1 <> pk_d && k2 <> pk_d then
           (* create veto *)
           let m = (pk_d, time3, group) in
           let veto = sign(Ak, m) in
           event e_Bridge_veto(BrDev, pk_d);
           out(ch_g, (m, veto)).
           (* IRS refresh... *)
       (* else: nothing *)


process
   (* init *)
   new group: bitstring;
   new group2: bitstring;
   out(ch_pub, group);
   out(ch_pub, group2);
   (* tell the attacker the current times *)
   new time1: bitstring;
   new time2: bitstring;
   new time3: bitstring;
   out(ch_pub, (time1, time2, time3));
   (* public keys *)
   out(ch_pub, pk(kA));
   out(ch_pub, pk(kB));
   (* key for d *)
   new kd: skey;
   out(ch_pub, pk(kd));
#if (d_COMPR)
   (* give the attacker (d) a valid key/ticket pair *)
   let ticket_Ad = sign(kA, pk2b(pk(kd))) in
   let ticket_Bd = sign(kB, pk2b(pk(kd))) in
   out(ch_pub, (kd, ticket_Ad, ticket_Bd));
#endif

   (* generate tickets *)
   new k1: skey;
   new k2: skey;
   let ticket_A_1 = sign(kA, pk2b(pk(k1))) in
   let ticket_B_1 = sign(kB, pk2b(pk(k1))) in
   let ticket_A_2 = sign(kA, pk2b(pk(k2))) in
   let ticket_B_2 = sign(kB, pk2b(pk(k2))) in

   (* start group g and g2 *)
   g (ch_g,   group,  pk(kA), pk(kB), time3) |
   g2(ch_pub, group2, pk(kA), pk(kB), time3) |
   (* start group devices gd1 and gd2 to vote against d *)
   gd(ch_A, ch_B, group, k1, ticket_A_1, ticket_B_1, pk(kd), time1) |
   gd(ch_A, ch_B, group, k2, ticket_A_2, ticket_B_2, pk(kd), time2) |
   (* start bridge groups A and B *)
   Bridge(A1, ch_A, ch_g, kA, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(A2, ch_A, ch_g, kA, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(B1, ch_B, ch_g, kB, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(B2, ch_B, ch_g, kB, pk(kA), pk(kB), time1, time2, time3)

