(*
#if FALSE

  @title:    Malware-Tolerant Network
  @authors:  Michael Denzel <research@michael-denzel.de>
  @date:     2017-05-03

  Warning: this is a raw file to generate ProVerif proofs.
  It includes C-macros and is not intended to be run directly.
  Please use the appended shellscript to generate the code.

#else
  GENERATED FILE

  @title:    Malware-Tolerant Network
  @authors:  Michael Denzel <research@michael-denzel.de>
  @date:     __DATE__

#endif
*)

(* ###################### CONFIG SECTION ###################### *)
(*set reconstructTrace = true. (* REMARK: traces sometimes cannot be created;
                                         rather use proof output *)
(*set verboseRules = true. (* print every single rule *)
(*set explainDerivation = false.*)
(* ############################################################ *)

(* defines *)
type skey.
type pkey.
type key. (* symmetric key *)
type sig.

(* constants *)
const A1: bitstring.
const A2: bitstring.
const B1: bitstring.
const B2: bitstring.

(* #################### XXX: trust model #################### *)
    (* channels *)
    (* second group *)
    free k_g2:       skey    .

    (* device d *)
    free ch_d:       channel .         (* public channel *)

    (* bridge group A *)
    free ch_A:       channel .          (* public channel *)
#if (A_COMPR)
    free kA:         skey    .
#else
    free kA:         skey    [private].
#endif


    (* bridge group B *)
    free ch_B:       channel .          (* public channel *)
#if (B_COMPR)
    free kB:         skey    .
#else
    free kB:         skey    [private].
#endif

(* ############################################################ *)


(* test variables to check if end of protocol etc. is reached *)
free success: bitstring [private].
free ch_pub: channel. (* public channel *)

(* Symmetric encryption *)
fun senc(key, bitstring): bitstring.
reduc forall kx:key, m:bitstring; sdec(kx, senc(kx, m)) = m.

(* Asymmetric encryption *)
fun pk(skey): pkey.
fun aenc(pkey, bitstring): bitstring.
reduc forall kx:skey, m:bitstring; adec(kx, aenc(pk(kx), m)) = m.

(* typecast *)
fun pk2b(pkey): bitstring.
reduc forall k:pkey; b2pk(pk2b(k)) = k.
fun sk2b(skey): bitstring.
reduc forall k:skey; b2sk(sk2b(k)) = k.

(* hash *)
fun mac(key, bitstring): bitstring.

(* signatures *)
fun sign(skey, bitstring): sig.
reduc forall kx:skey, m:bitstring; verify(pk(kx),m,sign(kx,m)) = m.



(* events to define control flows *)
event e_gd_promote(pkey, pkey). (* group device promote *)
event e_Bridge_promote(bitstring, pkey). (* bridge device promote *)
event e_d_accept_promotion.
event e_d_promote(skey).
event e_received_vote(pkey).

(* #################### XXX: QUERIES #################### *)
(* protocol runs through *)
(* "not attacker(success)" should be false/cannot be proved! *)
query attacker(success).

(* check if attacker can get both bridge keys *)
query attacker(kA).
query attacker(kB).

(* check if other groups can vote for d (they should not be allowed to!) *)
query event (e_received_vote(pk(k_g2))).

(* did promote work correctly? i.e. if there is a promote, honest device gd1 or gd2
   voted to promote pk_d, there were two votes (allow self-promotion), and the bridges
   were not skipped (= any bridge participated)
   *)
query pk_d: pkey, k1: pkey, k2: pkey;
      event (e_d_promote(kA)) ==> (
                                    event (e_d_accept_promotion) &&
                                    (
                                      event (e_Bridge_promote(A1, pk_d)) || event (e_Bridge_promote(A2, pk_d)) || 
                                      event (e_Bridge_promote(B1, pk_d)) || event (e_Bridge_promote(B2, pk_d))
                                    ) &&
                                    (event (e_gd_promote(k1, pk_d))      || event (e_gd_promote(k2, pk_d))) &&
                                    (event (e_received_vote(k1))         && event (e_received_vote(k2))) &&
                                    k1 <> k2
                                  ).

(* ###################################################### *)


(* device d: gets promoted *)
let d(
    (* input  *) ch_d: channel,
    (* output *) ch_A: channel, ch_B: channel,
    kd: skey, ticket_A: sig, ticket_B: sig,
    group: bitstring, pkA: pkey, pkB: pkey, time3: bitstring
    ) =
    (* receive promotion *)
    in(ch_d, (=pk(kd), =time3, promote_A: sig));
    in(ch_d, (=pk(kd), =time3, promote_B: sig));
#if (d_COMPR)
    (* a compromised d will not do any checks *)
#else
    let (=pk(kd), =time3) = verify(pkA, (pk(kd), time3), promote_A) in
    let (=pk(kd), =time3) = verify(pkB, (pk(kd), time3), promote_B) in
#endif
    event e_d_accept_promotion();
    (* send promote *)
    out(ch_A, promote_A);
    out(ch_A, promote_B);
    out(ch_B, promote_A);
    out(ch_B, promote_B);
    (* get bridge key*)
    in(ch_d, e: bitstring);
    let kA = b2sk(adec(kd, e)) in
    (* test bridge key *)
    new test: bitstring;
    let (=test) = verify(pkA, test, sign(kA, test)) in
    event e_d_promote(kA);
    out(ch_pub, success).


(* group device gd: votes to kick out d *)
let gd(
    (* input  *)
    (* output *) ch_A: channel, ch_B: channel,
    k: skey, ticket_A: sig, ticket_B: sig,
    group: bitstring, pk_d: pkey, ticket_A_d: sig, ticket_B_d: sig,
    time: bitstring
    ) =
    (* create promote *)
    let ticket = (pk_d, ticket_A_d, ticket_B_d) in
    let p = sign(k, (ticket, group, time)) in
    (* originally we would sign the ticket of d here
       (incl. pkey/group/time) *)
    event e_gd_promote(pk(k), pk_d);
    out(ch_A, (ticket, group, p, pk(k), ticket_A, ticket_B));
    out(ch_B, (ticket, group, p, pk(k), ticket_A, ticket_B)).


(* bridge group A/B: each provides half of the promote *)
let Bridge(BrDev: bitstring, (* bridge device BrDev (e.g. A1, A2, B1, ...) *)
    (* input  *) ch_in: channel,
    (* output *) ch_d: channel,
    Bridgek: skey, pkA: pkey, pkB: pkey,
    time1: bitstring, time2: bitstring, time3: bitstring
    ) =
    (* handle request 1 *)
       in(ch_in, (pk_d: pkey, ticket_A_d: sig, ticket_B_d: sig, group: bitstring, v1: sig,
                 k1: pkey, ticket_A1: sig, ticket_B1: sig));
       (* check ticket of d (=the promoted device) *)
       let (=pk_d, =group) = verify(pkA, (pk_d, group), ticket_A_d) in
       let (=pk_d, =group) = verify(pkB, (pk_d, group), ticket_B_d) in
       (* check ticket voter 1 *)
       let (=k1, =group) = verify(pkA, (k1, group), ticket_A1) in
       let (=k1, =group) = verify(pkB, (k1, group), ticket_B1) in
       (* check group promote 1 *)
       let ticket_d = (pk_d, ticket_A_d, ticket_B_d) in
       let (=ticket_d, =group, =time1) = verify(k1, (ticket_d, group, time1), v1) in
    (* handle request 2 *)
       in(ch_in, (=pk_d, =ticket_A_d, =ticket_B_d, =group, v2: sig, k2: pkey,
                 ticket_A2: sig, ticket_B2: sig));
       (* check ticket voter 2 *)
       let (=k2, =group) = verify(pkA, (k2, group), ticket_A2) in
       let (=k2, =group) = verify(pkB, (k2, group), ticket_B2) in
       (* check group promote 2 *)
       let (=ticket_d, =group, =time2) = verify(k2, (ticket_d, group, time2), v2) in
    if k1 <> k2 then
        event e_received_vote(k1);
        event e_received_vote(k2);
        (* create promote *)
        let m1 = (pk_d, time3) in
        let promote = sign(Bridgek, m1) in
        event e_Bridge_promote(BrDev, pk_d);
        out(ch_d, (m1, promote));
        (* in between may be some time, so m/pk_d/group is not stored any more;
           however time3 is the current time period and thus still available.
         *)
        (* check promote *)
        in(ch_in, (m2: bitstring, promote_A: sig));
        in(ch_in, (=m2, promote_B: sig));
        let (=m2) = verify(pkA, m2, promote_A) in
        let (=m2) = verify(pkB, m2, promote_B) in
        let (pk_d2: pkey, =time3) = m2 in
        (* IRS refresh... *)
        (* GKA... *)
        if pk(Bridgek) = pkA then
           (* send key - signature makes no sense because it would be self-signed *)
           let e = aenc(pk_d2, sk2b(Bridgek) (*and time4, secret_B*)) in
           out(ch_d, e).
        (* else: Bridge B -> not modelled here *)
    (* else: nothing *)


process
   (* init *)
   new group: bitstring;
   new group2: bitstring;
   out(ch_pub, group);
   out(ch_pub, group2);
   (* tell the attacker the current times *)
   new time1: bitstring;
   new time2: bitstring;
   new time3: bitstring;
   out(ch_pub, (time1, time2, time3));
   (* leak keys for compromised devices *)
   out(ch_pub, pk(kA));
   out(ch_pub, pk(kB));
   (* key for d *)
   new kd: skey;
   out(ch_pub, pk(kd));
   let ticket_A_d = sign(kA, (pk(kd), group)) in
   let ticket_B_d = sign(kB, (pk(kd), group)) in
#if (d_COMPR)
   (* give the attacker (d) a valid key/ticket pair *)
   out(ch_pub, (kd, ticket_A_d, ticket_B_d));
#endif

   (* generate tickets *)
   new k1: skey;
   new k2: skey;
   let ticket_A_1 = sign(kA, (pk(k1), group)) in
   let ticket_B_1 = sign(kB, (pk(k1), group)) in
   let ticket_A_2 = sign(kA, (pk(k2), group)) in
   let ticket_B_2 = sign(kB, (pk(k2), group)) in

   (* give the attacker tickets for another group *)
   out(ch_pub, sign(kA, (pk(k_g2), group2)));
   out(ch_pub, sign(kB, (pk(k_g2), group2)));

   (* start d *)
   d(ch_d, ch_A, ch_B, kd, ticket_A_d, ticket_B_d, group, pk(kA), pk(kB), time3) |
   (* start group devices gd1 and gd2 to promote d *)
   gd(ch_A, ch_B, k1, ticket_A_1, ticket_B_1, group, pk(kd), ticket_A_d, ticket_B_d, time1) |
   gd(ch_A, ch_B, k2, ticket_A_2, ticket_B_2, group, pk(kd), ticket_A_d, ticket_B_d, time2) |
   (* start bridge groups A and B *)
   Bridge(A1, ch_A, ch_d, kA, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(A2, ch_A, ch_d, kA, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(B1, ch_B, ch_d, kB, pk(kA), pk(kB), time1, time2, time3) |
   Bridge(B2, ch_B, ch_d, kB, pk(kA), pk(kB), time1, time2, time3)

