(*
#if FALSE

  @title:    Malware-Tolerant Network
  @authors:  Michael Denzel
  @date:     2018-02-26

  Warning: this is a raw file to generate ProVerif proofs.
  It includes C-macros and is not intended to be run directly.
  Please use the appended shellscript to generate the code.

#else
  GENERATED FILE

  @title:    Malware-Tolerant Network
  @authors:  Michael Denzel
  @date:     __DATE__

#endif
*)

(* ###################### CONFIG SECTION ###################### *)
(*set reconstructTrace = true. (* REMARK: traces sometimes cannot be created;
                                         rather use proof output *)
(*set verboseRules = true. (* print every single rule *)
(*set explainDerivation = false.*)
(* ############################################################ *)

(* defines *)
type skey.
type pkey.
type key. (* symmetric key *)
type sig.

(* constants *)
const A1: bitstring.
const A2: bitstring.
const B1: bitstring.
const B2: bitstring.
const ONE: bitstring.
const TWO: bitstring.
const group:  bitstring.
const group2: bitstring.

(* #################### XXX: trust model #################### *)
    (* device d *)
#if (d_COMPR)
    free ch_u_d:      channel .          (* d compromised *)
#else
    free ch_u_d:      channel [private]. (* d honest *)
#endif

    (* bridge group A *)
#if (A_COMPR)
    free kA:         skey    .          (* A compromised *)
#else
    free kA:         skey    [private]. (* A honest *)
#endif

    (* bridge group B *)
#if (B_COMPR)
    free kB:         skey    .          (* B compromised *)
#else
    free kB:         skey    [private]. (* B honest *)
#endif

    (* signup device d1 *)
#if (d1_COMPR)
    free k_d1:       skey    .          (* d1 compromised *)
#else
    free k_d1:       skey    [private]. (* d1 honest *)
#endif

    (* signup device d2 *)
#if (d2_COMPR)
    free k_d2:       skey    .          (* d2 compromised *)
#else
    free k_d2:       skey    [private]. (* d2 honest *)
#endif

    (* combinations *)
    (* ...for A *)
#if (A_COMPR || d1_COMPR)
    free ch_A_u1:     channel .
    free ch_u1_A:     channel .
#else
    free ch_A_u1:     channel [private].
    free ch_u1_A:     channel [private].
#endif
#if (A_COMPR || d2_COMPR)
    free ch_A_u2:     channel .
    free ch_u2_A:     channel .
#else
    free ch_A_u2:     channel [private].
    free ch_u2_A:     channel [private].
#endif


    (* ...for B *)
#if (B_COMPR || d1_COMPR)
    free ch_B_u1:     channel .
    free ch_u1_B:     channel .
#else
    free ch_B_u1:     channel [private].
    free ch_u1_B:     channel [private].
#endif
#if (B_COMPR || d2_COMPR)
    free ch_B_u2:     channel .
    free ch_u2_B:     channel .
#else
    free ch_B_u2:     channel [private].
    free ch_u2_B:     channel [private].
#endif

    (* ...for d *)
    (* channels between Bridges and d are only encrypted to
       hide 'vote to exclude' messages. If all messages apart
       from votes were public, then an attacker
       could identify (and block) the votes.
       Since ProVerif cannot model this, we can as well make the
       channels public.
    *)
    free ch_A_d:     channel .
    free ch_d_A:     channel .
    free ch_B_d:     channel .
    free ch_d_B:     channel .
    (* channel between d and g is not-encrypted *)
    free ch_d_g:     channel .

(* ############################################################ *)


(* test variables to check if end of protocol etc. is reached *)
free time:        bitstring .
free success:     bitstring [private].
free group2_join: bitstring [private].
free ch_pub:      channel   . (* public channel *)

(* Symmetric encryption *)
fun senc(key, bitstring): bitstring.
reduc forall kx:key, m:bitstring; sdec(kx, senc(kx, m)) = m.

(* Asymmetric encryption *)
fun pk(skey): pkey.
fun aenc(pkey, bitstring): bitstring.
reduc forall kx:skey, m:bitstring; adec(kx, aenc(pk(kx), m)) = m.

(* hash *)
fun mac(skey, bitstring): bitstring.

(* signatures *)
fun sign(skey, bitstring): sig.
reduc forall kx:skey, m:bitstring; verify(pk(kx),m,sign(kx,m)) = m.

(* events to define control flows *)
event user_accept(bitstring).
event g_accept(bitstring).
event Bridge_accept(bitstring, pkey, bitstring).


(* #################### XXX: QUERIES #################### *)
(* protocol runs through *)
(* "not attacker(success)" should be false/cannot be proved! *)
query attacker(success).

(* check if attacker can get both bridge keys *)
query attacker(kA).
query attacker(kB).

(* check if the attacker can make d join group2 *)
query attacker(group2_join).

(* check that if group accepts the ticket, it has to come from the user *) 
query event (g_accept(group)) ==> event (user_accept(group)).

(* ###################################################### *)


(* user: signs up through device 1 and device 2, sets up the group for d,
   and retrieves passwords which are then used to configure device d *)
let user(
    (* input  *) ch_A_u1: channel, ch_A_u2: channel, ch_B_u1: channel,
                 ch_B_u2: channel,
                 g: bitstring,
                 k_d1: skey, ticket_d1_A: sig, ticket_d1_B: sig,
                 k_d2: skey, ticket_d2_A: sig, ticket_d2_B: sig,
    (* output *) ch_u_d: channel,
                 ch_u1_A: channel, ch_u1_B: channel,
                 ch_u2_A: channel, ch_u2_B: channel
    ) =
    (* user sets group g for device d *)
    event user_accept(g);
    (* user through device 1 *)
        (* operations of device 1 *)
        (* device 1 gets group g from user *)
        let s1 = sign(k_d1, g) in
        out(ch_u1_A, (g, s1, pk(k_d1), time, ticket_d1_A));
        out(ch_u1_B, (g, s1, pk(k_d1), time, ticket_d1_B));
        in(ch_A_u1, pwA1: bitstring);
        in(ch_B_u1, pwB1: bitstring);
        let pw1 = (pwA1, pwB1) in
        (* display pw1 to the user *)
    (* user through device 2 *)
        (* operations of device 2 *)
        (* device 2 gets group g from user *)
        let s2 = sign(k_d2, g) in
        out(ch_u2_A, (g, s2, pk(k_d2), time, ticket_d2_A));
        out(ch_u2_B, (g, s2, pk(k_d2), time, ticket_d2_B));
        in(ch_A_u2, pwA2: bitstring);
        in(ch_B_u2, pwB2: bitstring);
        let pw2 = (pwA2, pwB2) in
        (* display pw2 to the user *)
    out(ch_u_d, (g, pw1, pw2)).

(* device d: signs up to get a ticket *)
let d(
    (* input  *) ch_u_d: channel, ch_A_d: channel, ch_B_d: channel,
    (* output *) ch_d_A: channel, ch_d_B: channel, ch_d_g: channel
    ) =
    in(ch_u_d, (g: bitstring,
                (pwA1: bitstring, pwB1: bitstring),
                (pwA2: bitstring, pwB2: bitstring)));
    let pwA = (pwA1, pwA2) in
    let pwB = (pwB1, pwB2) in
    (* create key and request ticket *)
    new k_d: skey;
#if (d_COMPR)
    out(ch_pub, k_d);
#endif
    let sA = sign(k_d, (pwA, g, pk(k_d))) in
    let sB = sign(k_d, (pwB, g, pk(k_d))) in
    out(ch_d_A, (pwA, g, pk(k_d), sA));
    out(ch_d_B, (pwB, g, pk(k_d), sB));
    (* get tickets *)
    in(ch_A_d, (m: bitstring, ticket_A: sig));
    in(ch_B_d, (=m, ticket_B: sig));
    (* send ticket to group *)
    out(ch_d_g, (m, ticket_A, ticket_B)).
    (* group key agreement... *)

(* group g: the group d wants to join; checks the ticket *)
let gr(
    (* input  *) ch_d_g: channel,
    (* output *)
    g: bitstring, pkA: pkey, pkB: pkey, secret: bitstring
    ) =
    in(ch_d_g, (m: bitstring, ticket_A: sig, ticket_B: sig));
    (* check ticket *)
    let (=m) = verify(pkA, m, ticket_A) in
    let (=m) = verify(pkB, m, ticket_B) in
    (* check timestamp and group *)
    let (pk_d: pkey, =time, =g) = m in
    (* accept key *)
    event g_accept(g);
    out(ch_pub, secret).
    (* group key agreement... *)


(* bridge group A/B: provides half of the ticket *)
let Bridge(BrDev: bitstring, (* bridge device BrDev (e.g. A1, A2, B1, ...) *)
    (* input  *) ch_d_Br: channel, ch_u1_Br: channel, ch_u2_Br: channel,
    (* output *) ch_Br_u1: channel, ch_Br_u2: channel, ch_Br_d: channel,
                 kBr: skey
    ) =
    (* get request 1 and verify ticket*)
    in(ch_u1_Br, (g: bitstring, s1: sig, pk_d1: pkey, =time,
                 ticket_d1: sig));
    let (=pk_d1, =time) = verify(pk(kBr), (pk_d1, time), ticket_d1) in
    let (=g) = verify(pk_d1, g, s1) in
    (* create pw for group *)
    let pw1 = mac(kBr, (ONE, g, time)) in
    out(ch_Br_u1, pw1);
    (* get request 2 and verify ticket*)
    in(ch_u2_Br, (=g, s2: sig, pk_d2: pkey, =time, ticket_d2: sig));
    let (=pk_d2, =time) = verify(pk(kBr), (pk_d2, time), ticket_d2) in
    let (=g) = verify(pk_d2, g, s2) in
    (* both requests agree on group g => Bridge accepts g *)
    (* create pw for group *)
    let pw2 = mac(kBr, (TWO, g, time)) in
    out(ch_Br_u2, pw2);
    (* handle request of new device d *)
    let pw = (pw1, pw2) in
    in(ch_d_Br, (=pw, =g, pk_d: pkey, s: sig));
    let (=pw, =g, =pk_d) = verify(pk_d, (pw, g, pk_d), s) in
    (* create ticket for d *)
    let m = (pk_d, time, g) in
    let ticket = sign(kBr, m) in
    event Bridge_accept(BrDev, pk_d, g);
    out(ch_Br_d, (m, ticket)).
    (* IRS refresh... *)


process
   (* init *)
   out(ch_pub, pk(kA));
   out(ch_pub, pk(kB));
   out(ch_pub, ONE);
   out(ch_pub, TWO);
   (* leak keys for compromised devices *)

   (* create tickets for d1 *)
   let ticket_d1_A = sign(kA, (pk(k_d1), time (*group irrelevant*))) in
   let ticket_d1_B = sign(kB, (pk(k_d1), time (*group irrelevant*))) in
   (* create tickets for d2 *)
   let ticket_d2_A = sign(kA, (pk(k_d2), time (*group irrelevant*))) in
   let ticket_d2_B = sign(kB, (pk(k_d2), time (*group irrelevant*))) in

   (* leak tickets *)
   out(ch_pub, ticket_d1_A);
   out(ch_pub, ticket_d1_B);
   out(ch_pub, ticket_d2_A);
   out(ch_pub, ticket_d2_B);

   (* start user *)
   user(ch_A_u1, ch_A_u2, ch_B_u1, ch_B_u2, group,
        k_d1, ticket_d1_A, ticket_d1_B,
        k_d2, ticket_d2_A, ticket_d2_B,
        ch_u_d, ch_u1_A, ch_u1_B, ch_u2_A, ch_u2_B) |
   (* start device d *)
   d(ch_u_d, ch_A_d, ch_B_d,
      ch_d_A, ch_d_B, ch_d_g) |
   (* start bridges A1, A2, B1, and B2 *)
   Bridge(A1, ch_d_A, ch_u1_A, ch_u2_A, ch_A_u1, ch_A_u2, ch_A_d, kA) |
   Bridge(A2, ch_d_A, ch_u1_A, ch_u2_A, ch_A_u1, ch_A_u2, ch_A_d, kA) |
   Bridge(B1, ch_d_B, ch_u1_B, ch_u2_B, ch_B_u1, ch_B_u2, ch_B_d, kB) |
   Bridge(B2, ch_d_B, ch_u1_B, ch_u2_B, ch_B_u1, ch_B_u2, ch_B_d, kB) |
   (* start recipient group g and g2 *)
   gr(ch_d_g, group,  pk(kA), pk(kB), success) |
   gr(ch_pub, group2, pk(kA), pk(kB), group2_join)


